  <!DOCTYPE html>
  <html lang="en">

  <head>
    <title>Javascript Racer v2</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #1a202c;
        /* Dark theme background */
        color: #e2e8f0;
        font-family: 'Inter', sans-serif;
      }

      #game-container {
        position: relative;
        box-sizing: border-box;
        /* Pastiin container hitung border/margin benar */
        width: 100vw;
        height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
      }

      #screen-area {
        flex: 1;
        width: 100%;
        margin: 0 8px 8px 8px;
        /* Hapus margin atas, biar nggak push ke atas berlebih. Bottom 8px aja buat jarak */
        max-height: calc(100vh - 120px);
        /* Default: Reserve space for controls + bezel */
        position: relative;
        /* Background diganti ke 6.gif */
        background-image: url('images/background/3.webp');
        background-size: 220vh 55vh;
        background-position: center-top;
        background-repeat: no-repeat;
        border: 8px solid #333;
        border-radius: 12px;
        box-sizing: border-box;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
      }

    @media (min-width: 768px) {
      #screen-area {
        border: 20px solid #2d3748;
        margin: 20px;
        max-height: none;
        flex: none;
        height: 100vh;
        margin: 0;
        border: none;
        border-radius: 0;
      }
    }

    @media (min-width: 768px) {
    #mobile-controls {
      display: none !important;
    }
  }

      #canvas {
        display: block;
        width: 100%;
        height: 100%;
        border-radius: 4px;
        /* Slight rounding inside bezel */
      }

      #controls-area {
        box-sizing: border-box;
        /* Border masuk ke height 120px, total pas 120px */
        width: 100%;
        height: 130px;
        background: linear-gradient(to top, #1a202c, #2d3748);
        border-top: 4px solid #333;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.5);
      }

#mobile-controls {
  position: absolute !important;
  bottom: 40px;                /* <-- ubah angka ini sesuai keinginan */
  left: 0;
  right: 0;
  display: flex;
  justify-content: space-evenly;
  align-items: flex-end;
  gap: 0.5rem;
  padding: 0 1.5rem;
  z-index: 30;                 /* pastikan di atas canvas */
  pointer-events: auto;
}

      #mobile-controls button {
        width: auto;
        height: auto;
        border-radius: 0%;
        border: none;
        font-size: 1.2rem;
        color: #000000;
        background: rgb(160, 153, 153);
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        transition: all 0.15s ease;
        pointer-events: auto;
        touch-action: manipulation;
        display: flex;
        align-items: center;
        justify-content: center;
        margin: 0 0.25rem;
      }

      #mobile-controls button:active {
        background: rgb(17, 104, 255);
        transform: scale(0.95);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
      }

      #accel-brake-controls,
      #steering-controls {
        /* Hapus atau comment out seluruh style ini, karena kita gabungkan semua tombol langsung ke #mobile-controls */
        /* Atau ganti jadi: display: contents; biar sub-container "hilang" dan tombol langsung flex di parent */
        display: contents;
        gap: 1.5rem;
      }

      #controls {
        position: fixed;
        top: 1rem;
        right: 1rem;
        background: rgba(45, 55, 72, 0.95);
        border-radius: 0.5rem;
        padding: 1rem;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        transition: transform 0.3s ease-in-out;
        opacity: 0;
        /* Hide controls visually */
        pointer-events: auto;
        /* Keep interactive */
      }

      #controls.hidden {
        transform: translateX(100%);
      }

      #controls-toggle {
        position: fixed;
        top: 1rem;
        right: 1rem;
        z-index: 50;
        opacity: 0;
        /* Hide toggle button visually */
        pointer-events: auto;
        /* Keep interactive */
      }

      .retro-button {
        position: relative;
        padding: 16px 32px;
        font-size: 18px;
        font-weight: bold;
        text-transform: uppercase;
        letter-spacing: 2px;
        color: #ffeb3b;
        background: linear-gradient(145deg, #d32f2f, #b71c1c);
        border: none;
        border-radius: 8px;
        box-shadow:
          0 6px 0 #7f0000,
          0 8px 10px rgba(0, 0, 0, 0.5),
          inset 0 2px 2px rgba(255, 255, 255, 0.2);
        cursor: pointer;
        transition: all 0.2s ease;
        outline: none;
        overflow: hidden;
      }

      .retro-button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        transition: left 0.5s ease;
      }

      .retro-button:hover {
        transform: translateY(2px);
        box-shadow:
          0 4px 0 #7f0000,
          0 6px 8px rgba(0, 0, 0, 0.4),
          inset 0 2px 2px rgba(255, 255, 255, 0.2);
        background: linear-gradient(145deg, #c62828, #9a0007);
      }

      .retro-button:active {
        transform: translateY(6px);
        box-shadow:
          0 0 0 #7f0000,
          0 2px 4px rgba(0, 0, 0, 0.3),
          inset 0 2px 2px rgba(255, 255, 255, 0.2);
      }

      .retro-button:hover::before {
        left: 100%;
      }

      .retro-button:focus {
        box-shadow:
          0 6px 0 #7f0000,
          0 8px 10px rgba(0, 0, 0, 0.5),
          0 0 0 3px rgba(255, 235, 59, 0.5),
          inset 0 2px 2px rgba(255, 255, 255, 0.2);
      }

      .retro-button::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle at center, rgba(255, 255, 255, 0.4) 0%, transparent 70%);
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .retro-button:hover::after {
        opacity: 1;
      }

      #instructions {
        position: fixed;
        bottom: 1rem;
        left: 1rem;
        background: rgba(45, 55, 72, 0.95);
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
      }

      #hud {
        position: fixed;
        top: 1rem;
        left: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        background: rgba(45, 55, 72, 0.95);
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        opacity: 0;
        /* Hide HUD visually */
        pointer-events: none;
        /* Disable pointer events for HUD */
      }

      .hud .value {
        color: #ed8936;
        /* Orange for values */
      }

      select,
      input[type="range"] {
        background: #4a5568;
        color: #e2e8f0;
        border: none;
        padding: 0.5rem;
        border-radius: 0.25rem;
        width: 100%;
      }

      label {
        font-size: 0.875rem;
        color: #a0aec0;
      }

      #finish-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.8);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 100;
        flex-direction: column;
        color: #fff;
        font-family: 'Inter', sans-serif;
      }

      #finish-screen h2 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
        color: #ffeb3b;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
      }

      #finish-screen p {
        font-size: 1.2rem;
        margin-bottom: 2rem;
        text-align: center;
        max-width: 80%;
      }
  #desktop-controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    z-index: 100;
    display: none; /* Default disembunyikan */
  }

  @media (min-width: 768px) {
  #desktop-controls {
    display: grid;
    grid-template-columns: 60px 60px 60px;
    grid-template-rows: 60px 60px;
    grid-template-areas:
      ". up ."
      "left center right"
      ". down .";
    gap: 8px;
  }
}

.desk-btn {
  width: 80px;
  height: 80px;
  border-radius: 0px;           /* sudut melengkung ringan (bisa diganti 0px kalau mau kotak lurus) */
 
  display: flex;
  align-items: center;
  justify-content: center;

  transition: all 0.15s ease;
  overflow: visible;             /* penting! biar gambar tidak dipotong */
}

.desk-btn img {
  width: 100%;           /* gambar di dalam tombol jadi lebih besar */
  height: 100%;
  object-fit: contain;
}

.desk-btn:active {

  transform: scale(0.95);
 
}
    </style>
  </head>

  <body>
    <div id="controls-info" class="hidden bg-gray-800 text-white p-4 rounded-lg shadow-lg" style="position: fixed; top: 1rem; right: 1rem; z-index: 100; opacity: 1; transition: opacity 0.5s ease-out;">
      <p>Use <strong>WASD</strong> or <strong>Arrow Keys</strong> to move.</p>
    </div>
    <div id="game-container">
      <div id="screen-area">
        <button id="controls-toggle"
          class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md transition">Controls</button>
        <table id="controls" class="hidden">
          <tr>
            <td colspan="2">
              <a href='v1.straight.html'>straight</a> |
              <a href='v2.curves.html'>curves</a>     |
              <a href='v3.hills.html'>hills</a>       |
              <a href='v4.final.html'>final</a>
            </td>
          </tr>
          <tr><td id="fps" colspan="2" class="text-right text-sm text-gray-400"></td></tr>
          <tr>
            <th><label for="resolution">Resolution:</label></th>
            <td>
              <select id="resolution">
                <option value="fine">Fine (1280x960)</option>
                <option selected value="high">High (1024x768)</option>
                <option value="medium">Medium (640x480)</option>
                <option value="low">Low (480x360)</option>
              </select>
            </td>
          </tr>
          <tr>
            <th><label for="lanes">Lanes:</label></th>
            <td>
              <select id="lanes">
                <option>1</option>
                <option>2</option>
                <option selected>3</option>
                <option>4</option>
              </select>
            </td>
          </tr>
          <tr>
            <th><label for="roadWidth">Road Width (<span id="currentRoadWidth"></span>):</label></th>
            <td><input id="roadWidth" type="range" min="500" max="3000" title="integer (500-3000)"></td>
          </tr>
          <tr>
            <th><label for="cameraHeight">Camera Height (<span id="currentCameraHeight"></span>):</label></th>
            <td><input id="cameraHeight" type="range" min="500" max="5000" title="integer (500-5000)"></td>
          </tr>
          <tr>
            <th><label for="drawDistance">Draw Distance (<span id="currentDrawDistance"></span>):</label></th>
            <td><input id="drawDistance" type="range" min="100" max="500" title="integer (100-500)"></td>
          </tr>
          <tr>
            <th><label for="fieldOfView">Field of View (<span id="currentFieldOfView"></span>):</label></th>
            <td><input id="fieldOfView" type="range" min="80" max="140" title="integer (80-140)"></td>
          </tr>
          <tr>
            <th><label for="fogDensity">Fog Density (<span id="currentFogDensity"></span>):</label></th>
            <td><input id="fogDensity" type="range" min="0" max="50" title="integer (0-50)"></td>
          </tr>
        </table>

        <div id="racer">
          <div id="hud">
            <span id="speed" class="hud">Speed: <span id="speed_value" class="value">0</span> mph</span>
            <span id="current_lap_time" class="hud">Time: <span id="current_lap_time_value"
                class="value">0.0</span></span>
            <span id="last_lap_time" class="hud">Last Lap: <span id="last_lap_time_value" class="value">0.0</span></span>
            <span id="fast_lap_time" class="hud">Fastest Lap: <span id="fast_lap_time_value"
                class="value">0.0</span></span>
          </div>
          <canvas id="canvas">
            Sorry, this example cannot be run because your browser does not support the &lt;canvas&gt; element
          </canvas>
        </div>
      </div>
      <div id="controls-area">

<div id="mobile-controls" class="md:hidden">  <!-- md:hidden = Tailwind: sembunyi di â‰¥768px -->
    <div id="accel-brake-controls">
      <button id="brake" class="control-btn" title="Brake">
        <img src="./images/down.webp" alt="Brake" width="100%">
      </button>
      <button id="accel" class="control-btn" title="Accelerate">
        <img src="./images/up.webp" alt="Accelerate" width="100%">
      </button>
    </div>
    <div id="steering-controls">
      <button id="left" class="control-btn" title="Steer Left">
        <img src="./images/left.webp" alt="Steer Left" width="100%">
      </button>
      <button id="right" class="control-btn" title="Steer Right">
        <img src="./images/right.webp" alt="Steer Right" width="100%">
      </button>
    </div>
  </div>
    </div>

    <div id="desktop-controls">
    <div class="desk-btn" id="desk-up" style="grid-area: up;">
      <img src="./images/up.webp" alt="Accelerate" class="w-full h-full object-contain">
    </div>
    <div class="desk-btn" id="desk-left" style="grid-area: left;">
      <img src="./images/left.webp" alt="Left" class="w-full h-full object-contain">
    </div>
    <div class="desk-btn center" style="grid-area: center;"></div>
    <div class="desk-btn" id="desk-right" style="grid-area: right;">
      <img src="./images/right.webp" alt="Right" class="w-full h-full object-contain">
    </div>
    <div class="desk-btn" id="desk-down" style="grid-area: down;">
      <img src="./images/down.webp" alt="Brake" class="w-full h-full object-contain">
    </div>
  </div>

    <!-- Finish Screen Overlay -->
    <div id="finish-screen">
      <h2>Race Completed!</h2>
      <p>Congratulations! You have finished the mini race. Returning to quiz in a moment...</p>
    </div>

    <script src="stats.js"></script>
    <script src="common.js"></script>
    <script>
      // Parse URL parameters
      const playerId = localStorage.getItem("playerId");
      const urlParams = new URLSearchParams(window.location.search);
      const startIndex = urlParams.get('startIndex');
      const roomCode = urlParams.get('roomCode');

      // Original game JavaScript code from v2
      var cars = [];  // Array untuk menyimpan mobil
      var totalCars = 65;  // Jumlah total mobil (bisa diubah, misal 20 untuk lebih sedikit)
      var fps = 60;
      var step = 1 / fps;
      var width = 1024;
      var height = 768;
      var centrifugal = 0.3;
      var offRoadDecel = 0.99;
      var skySpeed = 0.001;
      var hillSpeed = 0.002;
      var treeSpeed = 0.003;
      var skyOffset = 0;
      var hillOffset = 0;
      var treeOffset = 0;
      var segments = [];
      var stats = Game.stats('fps');
      var canvas = Dom.get('canvas');
      var ctx = canvas.getContext('2d');
      var background = null;
      var sprites = null;
      var resolution = null;
      var roadWidth = 2000;
      var segmentLength = 200;
      var rumbleLength = 3;
      var trackLength = null;
      var lanes = 3;
      var fieldOfView = 100;
      var cameraHeight = 1000;
      var cameraDepth = null;
      var drawDistance = 200;
      var playerX = 0;
      var playerZ = null;
      var fogDensity = 5;
      var position = 0;
      var speed = 0;
      var maxSpeed = segmentLength / step;
      var accel = maxSpeed / 5;
      var breaking = -maxSpeed;
      var decel = -maxSpeed / 5;
      var offRoadDecel = -maxSpeed / 2;
      var offRoadLimit = maxSpeed / 4;
      var currentLapTime = 0;
      var lastLapTime = null;
      var gameFinished = false; // New flag for finish
      var keyLeft = false;
      var keyRight = false;
      var keyFaster = false;
      var keySlower = false;
      var hud = {
        speed: { value: null, dom: Dom.get('speed_value') },
        current_lap_time: { value: null, dom: Dom.get('current_lap_time_value') },
        last_lap_time: { value: null, dom: Dom.get('last_lap_time_value') },
        fast_lap_time: { value: null, dom: Dom.get('fast_lap_time_value') }
      };

      // Fungsi untuk haptic feedback (kompatibel dengan perangkat yang mendukung)
      function triggerHapticFeedback(intensity = 'light') {
        if (navigator.vibrate) {
          switch (intensity) {
            case 'light': navigator.vibrate(10); break;
            case 'medium': navigator.vibrate(50); break;
            case 'strong': navigator.vibrate(100); break;
          }
        }
      }

      // Fungsi untuk handle touch events dengan pencegahan default dan haptic
      function handleTouchStart(e, flagSetter) {
        e.preventDefault();
        flagSetter(true);
        triggerHapticFeedback('light');
      }

      function handleTouchEnd(e, flagSetter) {
        e.preventDefault();
        flagSetter(false);
        triggerHapticFeedback('light');
      }

        function update(dt) {
          if (gameFinished) { speed = 0; return; }
          var n, car, carW;  // TAMBAH INI
          var playerSegment = findSegment(position + playerZ);
          var playerW = SPRITES.PLAYER_STRAIGHT.w * SPRITES.SCALE;

        var playerSegment = findSegment(position + playerZ);
        var playerW = SPRITES.PLAYER_STRAIGHT.w * SPRITES.SCALE;
        var speedPercent = speed / maxSpeed;
        var dx = dt * 2 * speedPercent;
        var startPosition = position;
        updateCars(dt, playerSegment, playerW);

        position = Util.increase(position, dt * speed, trackLength);

        skyOffset = Util.increase(skyOffset, skySpeed * playerSegment.curve * speedPercent, 1);
        hillOffset = Util.increase(hillOffset, hillSpeed * playerSegment.curve * speedPercent, 1);
        treeOffset = Util.increase(treeOffset, treeSpeed * playerSegment.curve * speedPercent, 1);

        if (keyLeft)
          playerX = playerX - dx;
        else if (keyRight)
          playerX = playerX + dx;

        playerX = playerX - (dx * speedPercent * playerSegment.curve * centrifugal);

        if (keyFaster)
          speed = Util.accelerate(speed, accel, dt);
        else if (keySlower)
          speed = Util.accelerate(speed, breaking, dt);
        else
          speed = Util.accelerate(speed, decel, dt);

        if (((playerX < -1) || (playerX > 1)) && (speed > offRoadLimit))
          speed = Util.accelerate(speed, offRoadDecel, dt);

        for (n = 0; n < playerSegment.cars.length; n++) {
            car = playerSegment.cars[n];
            carW = car.sprite.w * SPRITES.SCALE;
        if (speed > car.speed) {
          if (Util.overlap(playerX, playerW, car.offset, carW, 0.8)) {
            speed = car.speed * (car.speed / speed);
            position = Util.increase(car.z, -playerZ, trackLength);
            break;
          }
        }
      }

        playerX = Util.limit(playerX, -2, 2);
        speed = Util.limit(speed, 0, maxSpeed);

        if (position > playerZ) {
          if (currentLapTime && (startPosition < playerZ)) {
            lastLapTime = currentLapTime;
            currentLapTime = 0;
            if (lastLapTime <= Util.toFloat(Dom.storage.fast_lap_time)) {
              Dom.storage.fast_lap_time = lastLapTime;
              updateHud('fast_lap_time', formatTime(lastLapTime));
              Dom.addClassName('fast_lap_time', 'fastest');
              Dom.addClassName('last_lap_time', 'fastest');
            } else {
              Dom.removeClassName('fast_lap_time', 'fastest');
              Dom.removeClassName('last_lap_time', 'fastest');
            }
            updateHud('last_lap_time', formatTime(lastLapTime));
            Dom.show('last_lap_time');

            // Set game as finished after one lap
            gameFinished = true;

            document.getElementById('finish-screen').style.display = 'flex';
            window.parent.postMessage({ type: 'racing_finished' }, '*');

            // Otomatis redirect setelah 2 detik
            // setTimeout(() => {
            //   if (roomCode && startIndex) {
            //     window.location.href = `/player/${roomCode}/game?startIndex=${startIndex}`;
            //   } else {
            //     // Fallback if no params
            //     window.history.back();
            //   }
            // }, 2000);
          } else {
            currentLapTime += dt;
          }
        }
        updateHud('speed', 5 * Math.round(speed / 500));
        updateHud('current_lap_time', formatTime(currentLapTime));
      }

      function updateHud(key, value) {
        if (hud[key].value !== value) {
          hud[key].value = value;
          Dom.set(hud[key].dom, value);
        }
      }

      function formatTime(dt) {
        var minutes = Math.floor(dt / 60);
        var seconds = Math.floor(dt - (minutes * 60));
        var tenths = Math.floor(10 * (dt - Math.floor(dt)));
        if (minutes > 0) return minutes + "." + (seconds < 10 ? "0" : "") + seconds + "." + tenths;
        else return seconds + "." + tenths;
      }

      function render() {
        var baseSegment = findSegment(position);
        var basePercent = Util.percentRemaining(position, segmentLength);
        var maxy = height;

        var x = 0;
        var dx = - (baseSegment.curve * basePercent);

        ctx.clearRect(0, 0, width, height);

        // Render.background calls commented out since background is via CSS
        // Render.background(ctx, background, width, height, BACKGROUND.SKY, skyOffset);
        // Render.background(ctx, background, width, height, BACKGROUND.HILLS, hillOffset);
        // Render.background(ctx, background, width, height, BACKGROUND.TREES, treeOffset);

        var n, segment;

        for (n = 0; n < drawDistance; n++) {
          segment = segments[(baseSegment.index + n) % segments.length];
          segment.looped = segment.index < baseSegment.index;
          segment.fog = Util.exponentialFog(n / drawDistance, fogDensity);

          Util.project(segment.p1, (playerX * roadWidth) - x, cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);
          Util.project(segment.p2, (playerX * roadWidth) - x - dx, cameraHeight, position - (segment.looped ? trackLength : 0), cameraDepth, width, height, roadWidth);

          x = x + dx;
          dx = dx + segment.curve;

          if ((segment.p1.camera.z <= cameraDepth) ||
              (segment.p2.screen.y >= maxy))
            continue;

          Render.segment(ctx, width, lanes,
            segment.p1.screen.x,
            segment.p1.screen.y,
            segment.p1.screen.w,
            segment.p2.screen.x,
            segment.p2.screen.y,
            segment.p2.screen.w,
            segment.fog,
            segment.color);

   
          maxy = segment.p2.screen.y;
          segment.clip = maxy;  // TAMBAH INI
        }

        for (n = (drawDistance - 1); n > 0; n--) {
        segment = segments[(baseSegment.index + n) % segments.length];
        var i, car, sprite, spriteScale, spriteX, spriteY;
        for (i = 0; i < segment.cars.length; i++) {
          car = segment.cars[i];
          sprite = car.sprite;
          spriteScale = Util.interpolate(segment.p1.screen.scale, segment.p2.screen.scale, car.percent);
          spriteX = Util.interpolate(segment.p1.screen.x, segment.p2.screen.x, car.percent) + (spriteScale * car.offset * roadWidth * width / 2);
          spriteY = Util.interpolate(segment.p1.screen.y, segment.p2.screen.y, car.percent);
          Render.sprite(ctx, width, height, resolution, roadWidth, sprites, car.sprite, spriteScale, spriteX, spriteY, -0.5, -1, segment.p1.screen.y);
        }
      }

        Render.player(ctx, width, height, resolution, roadWidth, sprites, speed / maxSpeed,
          cameraDepth / playerZ,
          width / 2,
          height,
          speed * (keyLeft ? -1 : keyRight ? 1 : 0),
          0);
      }

        function addSegment(curve) {
          var n = segments.length;
          segments.push({
            index: n,
            p1: { world: { z: n * segmentLength }, camera: {}, screen: {} },
            p2: { world: { z: (n + 1) * segmentLength }, camera: {}, screen: {} },
            curve: curve,
            cars: [],  // Tambahkan ini
            color: Math.floor(n / rumbleLength) % 2 ? COLORS.DARK : COLORS.LIGHT
          });
        }

      function addRoad(enter, hold, leave, curve) {
        var n;
        for (n = 0; n < enter; n++)
          addSegment(Util.easeIn(0, curve, n / enter));
        for (n = 0; n < hold; n++)
          addSegment(curve);
        for (n = 0; n < leave; n++)
          addSegment(Util.easeInOut(curve, 0, n / leave));
      }

      var ROAD = {
        LENGTH: { NONE: 0, SHORT: 25, MEDIUM: 50, LONG: 100 },
        CURVE: { NONE: 0, EASY: 2, MEDIUM: 4, HARD: 6 }
      };

      function addStraight(num) {
        num = num || ROAD.LENGTH.MEDIUM;
        addRoad(num, num, num, 0);
      }

      function addCurve(num, curve) {
        num = num || ROAD.LENGTH.MEDIUM;
        curve = curve || ROAD.CURVE.MEDIUM;
        addRoad(num, num, num, curve);
      }

      function addSCurves() {
        addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY);
        addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM);
        addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.CURVE.EASY);
        addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.EASY);
        addRoad(ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, ROAD.LENGTH.MEDIUM, -ROAD.CURVE.MEDIUM);
      }

      function resetRoad() {
        segments = [];

        addStraight(ROAD.LENGTH.SHORT / 4);
        // addSCurves();
        // addStraight(ROAD.LENGTH.LONG);
        addCurve(ROAD.LENGTH.MEDIUM, ROAD.CURVE.MEDIUM);
        addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM);
        // addStraight();
        // addSCurves();
        addCurve(ROAD.LENGTH.LONG, -ROAD.CURVE.MEDIUM);
        addCurve(ROAD.LENGTH.LONG, ROAD.CURVE.MEDIUM);
        // addStraight();
        addSCurves();
        addCurve(ROAD.LENGTH.LONG, -ROAD.CURVE.EASY);

        segments[findSegment(playerZ).index + 2].color = COLORS.START;
        segments[findSegment(playerZ).index + 3].color = COLORS.START;
        for (var n = 0; n < rumbleLength; n++)
          segments[segments.length - 1 - n].color = COLORS.FINISH;

        trackLength = segments.length * segmentLength;
        resetCars();  // Panggil untuk inisialisasi mobil
      }

      function resetCars() {
        cars = [];
        var n, car, segment, offset, z, sprite, speed;
        for (n = 0; n < totalCars; n++) {
          offset = Math.random() * Util.randomChoice([-0.8, 0.8]);
          z = Math.floor(Math.random() * segments.length) * segmentLength;
          sprite = Util.randomChoice(SPRITES.CARS);
          speed = maxSpeed / 4 + Math.random() * maxSpeed / (sprite == SPRITES.SEMI ? 4 : 2);
          car = { offset: offset, z: z, sprite: sprite, speed: speed };
          segment = findSegment(car.z);
          segment.cars = segment.cars || [];  // Inisialisasi array cars jika belum ada
          segment.cars.push(car);
          cars.push(car);
        }
      }

      function updateCars(dt, playerSegment, playerW) {
      var n, car, oldSegment, newSegment;
      for (n = 0; n < cars.length; n++) {
        car = cars[n];
        oldSegment = findSegment(car.z);
        car.offset = car.offset + updateCarOffset(car, oldSegment, playerSegment, playerW);
        car.z = Util.increase(car.z, dt * car.speed, trackLength);
        car.percent = Util.percentRemaining(car.z, segmentLength);
        newSegment = findSegment(car.z);
        if (oldSegment != newSegment) {
          var index = oldSegment.cars.indexOf(car);
          oldSegment.cars.splice(index, 1);
          newSegment.cars.push(car);
        }
      }
    }

function updateCarOffset(car, carSegment, playerSegment, playerW) {
  var i, j, dir, segment, otherCar, otherCarW, lookahead = 10, carW = car.sprite.w * SPRITES.SCALE;  // lookahead=10
  if ((carSegment.index - playerSegment.index) > drawDistance) return 0;
  for (i = 1; i < lookahead; i++) {
    segment = segments[(carSegment.index + i) % segments.length];
    if ((segment === playerSegment) && (car.speed > speed) && (Util.overlap(playerX, playerW, car.offset, carW, 1.2))) {
      // HAPUS: if (options.totalCars) ... (baris ini bikin error!)
      if (playerX > 0.5) dir = -1; // Opsional, untuk tweak UI jika perlu
          if (playerX > 0.5) dir = -1;
          else if (playerX < -0.5) dir = 1;
          else dir = (car.offset > playerX) ? 1 : -1;
          return dir * 1 / i * (car.speed - speed) / maxSpeed;
        }
        for (j = 0; j < segment.cars.length; j++) {
          otherCar = segment.cars[j];
          otherCarW = otherCar.sprite.w * SPRITES.SCALE;
          if ((car.speed > otherCar.speed) && Util.overlap(car.offset, carW, otherCar.offset, otherCarW, 1.2)) {
            if (otherCar.offset > 0.5) dir = -1;
            else if (otherCar.offset < -0.5) dir = 1;
            else dir = (car.offset > otherCar.offset) ? 1 : -1;
            return dir * 1 / i * (car.speed - otherCar.speed) / maxSpeed;
          }
        }
      }
      if (car.offset < -0.9) return 0.1;
      else if (car.offset > 0.9) return -0.1;
      else return 0;
    }

      function findSegment(z) {
        return segments[Math.floor(z / segmentLength) % segments.length];
      }

      Game.run({
        canvas: canvas, render: render, update: update, stats: stats, step: step,
        images: ["background", "sprites"],
        keys: [
          { keys: [KEY.LEFT, KEY.A], mode: 'down', action: function () { if (!gameFinished) keyLeft = true; } },
          { keys: [KEY.RIGHT, KEY.D], mode: 'down', action: function () { if (!gameFinished) keyRight = true; } },
          { keys: [KEY.UP, KEY.W], mode: 'down', action: function () { if (!gameFinished) keyFaster = true; } },
          { keys: [KEY.DOWN, KEY.S], mode: 'down', action: function () { if (!gameFinished) keySlower = true; } },
          { keys: [KEY.LEFT, KEY.A], mode: 'up', action: function () { keyLeft = false; } },
          { keys: [KEY.RIGHT, KEY.D], mode: 'up', action: function () { keyRight = false; } },
          { keys: [KEY.UP, KEY.W], mode: 'up', action: function () { keyFaster = false; } },
          { keys: [KEY.DOWN, KEY.S], mode: 'up', action: function () { keySlower = false; } }
        ],
        ready: function (images) {
          background = images[0];
          sprites = images[1];
          reset();
          Dom.storage.fast_lap_time = Dom.storage.fast_lap_time || 180;
          updateHud('fast_lap_time', formatTime(Util.toFloat(Dom.storage.fast_lap_time)));
        }
      });

      function reset(options) {
        options = options || {};
        canvas.width = width = Util.toInt(options.width, width);
        canvas.height = height = Util.toInt(options.height, height);
        lanes = Util.toInt(options.lanes, lanes);
        roadWidth = Util.toInt(options.roadWidth, roadWidth);
        cameraHeight = Util.toInt(options.cameraHeight, cameraHeight);
        drawDistance = Util.toInt(options.drawDistance, drawDistance);
        fogDensity = Util.toInt(options.fogDensity, fogDensity);
        fieldOfView = Util.toInt(options.fieldOfView, fieldOfView);
        segmentLength = Util.toInt(options.segmentLength, segmentLength);
        rumbleLength = Util.toInt(options.rumbleLength, rumbleLength);
        cameraDepth = 1 / Math.tan((fieldOfView / 2) * Math.PI / 180);
        playerZ = (cameraHeight * cameraDepth);
        resolution = height / 480;
        refreshTweakUI();

        if ((segments.length == 0) || (options.segmentLength) || (options.rumbleLength))
          resetRoad();
      }

      Dom.on('resolution', 'change', function (ev) {
        var w, h, ratio;
        switch (ev.target.options[ev.target.selectedIndex].value) {
          case 'fine': w = 1280; h = 960; ratio = w / width; break;
          case 'high': w = 1024; h = 768; ratio = w / width; break;
          case 'medium': w = 640; h = 480; ratio = w / width; break;
          case 'low': w = 480; h = 360; ratio = w / width; break;
        }
        reset({ width: w, height: h });
        Dom.blur(ev);
      });

      Dom.on('lanes', 'change', function (ev) { Dom.blur(ev); reset({ lanes: ev.target.options[ev.target.selectedIndex].value }); });
      Dom.on('roadWidth', 'change', function (ev) { Dom.blur(ev); reset({ roadWidth: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
      Dom.on('cameraHeight', 'change', function (ev) { Dom.blur(ev); reset({ cameraHeight: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
      Dom.on('drawDistance', 'change', function (ev) { Dom.blur(ev); reset({ drawDistance: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
      Dom.on('fieldOfView', 'change', function (ev) { Dom.blur(ev); reset({ fieldOfView: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });
      Dom.on('fogDensity', 'change', function (ev) { Dom.blur(ev); reset({ fogDensity: Util.limit(Util.toInt(ev.target.value), Util.toInt(ev.target.getAttribute('min')), Util.toInt(ev.target.getAttribute('max'))) }); });

      function refreshTweakUI() {
        Dom.get('lanes').selectedIndex = lanes - 1;
        Dom.get('currentRoadWidth').innerHTML = Dom.get('roadWidth').value = roadWidth;
        Dom.get('currentCameraHeight').innerHTML = Dom.get('cameraHeight').value = cameraHeight;
        Dom.get('currentDrawDistance').innerHTML = Dom.get('drawDistance').value = drawDistance;
        Dom.get('currentFieldOfView').innerHTML = Dom.get('fieldOfView').value = fieldOfView;
        Dom.get('currentFogDensity').innerHTML = Dom.get('fogDensity').value = fogDensity;
      }

      // Toggle controls visibility
      Dom.get('controls-toggle').addEventListener('click', function () {
        var controls = Dom.get('controls');
        var toggleButton = Dom.get('controls-toggle');
        controls.classList.toggle('hidden');
        toggleButton.textContent = controls.classList.contains('hidden') ? 'Show Controls' : 'Hide Controls';
      });

      // Full-screen canvas resizing - Adjusted for new layout
      function resizeCanvas() {
        const screenArea = document.getElementById('screen-area');
        canvas.width = screenArea.clientWidth;
        canvas.height = screenArea.clientHeight;
        width = canvas.width;
        height = canvas.height;
        resolution = height / 480;
        reset({ width: width, height: height });
      }

      // Fungsi untuk update visibilitas kontrol mobile berdasarkan lebar layar
 
      window.addEventListener('resize', () => {
        resizeCanvas();
        
      });

      resizeCanvas();


      // Mobile Controls - Selalu tambahkan event listener, tapi visibilitas dikontrol via CSS/JS
      const leftBtn = document.getElementById('left');
      const rightBtn = document.getElementById('right');
      const accelBtn = document.getElementById('accel');
      const brakeBtn = document.getElementById('brake');

      // Use handle functions for consistency and haptic
      leftBtn.addEventListener('touchstart', (e) => handleTouchStart(e, () => { if (!gameFinished) keyLeft = true; }));
      leftBtn.addEventListener('touchend', (e) => handleTouchEnd(e, () => { keyLeft = false; }));

      rightBtn.addEventListener('touchstart', (e) => handleTouchStart(e, () => { if (!gameFinished) keyRight = true; }));
      rightBtn.addEventListener('touchend', (e) => handleTouchEnd(e, () => { keyRight = false; }));

      accelBtn.addEventListener('touchstart', (e) => handleTouchStart(e, () => { if (!gameFinished) keyFaster = true; }));
      accelBtn.addEventListener('touchend', (e) => handleTouchEnd(e, () => { keyFaster = false; }));

      brakeBtn.addEventListener('touchstart', (e) => handleTouchStart(e, () => { if (!gameFinished) keySlower = true; }));
      brakeBtn.addEventListener('touchend', (e) => handleTouchEnd(e, () => { keySlower = false; }));

      // Prevent zoom and scroll on touch
      document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
      document.addEventListener('gesturestart', (e) => e.preventDefault());
    </script>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
        if (!isTouchDevice) {
          const controlsInfo = document.getElementById('controls-info');
          if (controlsInfo) {
            controlsInfo.classList.remove('hidden');
            setTimeout(() => {
              controlsInfo.style.opacity = '0';
              setTimeout(() => {
                controlsInfo.remove();
              }, 500); // Wait for fade out to complete
            }, 3000);
          }
        }
      });
      const deskUp    = document.getElementById('desk-up');
const deskDown  = document.getElementById('desk-down');
const deskLeft  = document.getElementById('desk-left');
const deskRight = document.getElementById('desk-right');

function handlePress(flagSetter) {
  return function(e) {
    e.preventDefault();
    if (!gameFinished) flagSetter(true);
  };
}

function handleRelease(flagSetter) {
  return function(e) {
    e.preventDefault();
    flagSetter(false);
  };
}

deskUp.addEventListener('mousedown', handlePress(() => { keyFaster = true; }));
deskUp.addEventListener('mouseup',   handleRelease(() => { keyFaster = false; }));
deskUp.addEventListener('mouseleave', handleRelease(() => { keyFaster = false; }));

deskDown.addEventListener('mousedown', handlePress(() => { keySlower = true; }));
deskDown.addEventListener('mouseup',   handleRelease(() => { keySlower = false; }));
deskDown.addEventListener('mouseleave', handleRelease(() => { keySlower = false; }));

deskLeft.addEventListener('mousedown', handlePress(() => { keyLeft = true; }));
deskLeft.addEventListener('mouseup',   handleRelease(() => { keyLeft = false; }));
deskLeft.addEventListener('mouseleave', handleRelease(() => { keyLeft = false; }));

deskRight.addEventListener('mousedown', handlePress(() => { keyRight = true; }));
deskRight.addEventListener('mouseup',   handleRelease(() => { keyRight = false; }));
deskRight.addEventListener('mouseleave', handleRelease(() => { keyRight = false; }));
    </script>
  </body>

  </html>